<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Auction Dashboard</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/eventdetail.css" />
  <link rel="stylesheet" href="css/auction.css" />
  <script>
    // Restrict page to managers (auth.js respects this)
    window.requiredRoles = ["manager"];
  </script>
  <script src="/config.js"></script>
  <script src="/auth.js"></script>
</head>
<body>
  <nav class="navbar">
    <div class="nav-container">
      <a href="manager.html" class="brand">Tendersmith</a>
      <ul class="nav-links">
        <li><a href="manager.html">Home</a></li>
        <li><a href="events.html">Events</a></li>
        <li><a href="organisations.html">Organisations</a></li>
        <li><a href="stats.html">Stats</a></li>
        <li><a href="account.html">Account</a></li>
        <li><button id="messages-btn" class="nav-icon-btn">💬</button></li>
      </ul>
    </div>
  </nav>

  <div class="event-tabs">
    <div class="tab" data-tab="overview">Overview</div>
    <div class="tab" data-tab="lots">Lots</div>
    <div class="tab" data-tab="lines">All Line Items</div>
    <div class="tab" data-tab="members">Members</div>
    <div class="tab" data-tab="docs">Documents</div>
    <div class="tab" data-tab="responses">Responses</div>
    <div class="tab active" data-tab="pricing">Pricing</div>
  </div>

  <div class="auction-container">
    <!-- Auction Header -->
    <div class="auction-header">
      <div class="auction-title-section">
        <h1 id="auction-title">Live Auction</h1>
        <span id="auction-status-badge" class="status-badge offline">OFFLINE</span>
      </div>
      <div class="auction-timer-section">
        <div id="time-main" class="timer-display">Loading...</div>
        <div id="time-sub" class="timer-subtitle"></div>
      </div>
      <div class="auction-controls-section">
        <button id="pause-resume-btn" class="btn-control" disabled>PAUSE</button>
        <button id="debug-start-now-btn" class="btn-control">DEBUG: Start Now/Restart</button>
      </div>
    </div>

    <!-- Stats Bar -->
    <div class="stats-bar">
      <div class="stat-item">
        <span class="stat-label">Total Bids</span>
        <span class="stat-value" id="total-bids-value">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Bidders Connected</span>
        <span class="stat-value" id="bidders-connected-value">0 / 0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Extensions</span>
        <span class="stat-value" id="extensions-value">0</span>
        <span class="stat-subtitle" id="extension-settings">Loading...</span>
      </div>
    </div>

    <!-- Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <div id="filter-dropdown" class="chart-filter-dropdown">
          <div class="filter-selected" id="filter-selected">
            <span id="filter-selected-text">Total Savings</span>
            <svg class="filter-arrow" width="12" height="12" viewBox="0 0 12 12">
              <path fill="currentColor" d="M6 9L1 4h10z"/>
            </svg>
          </div>
          <div class="filter-menu" id="filter-menu" style="display: none;">
            <div class="filter-option" data-value="all">Total Savings</div>
          </div>
        </div>
      </div>
      <canvas id="bid-chart"></canvas>
    </div>

    <!-- Tables Grid -->
    <div class="tables-grid">
      <!-- Ranked Bidders -->
      <div class="table-section">
        <h2>Ranked Bidders by Total Savings</h2>
        <div class="table-scroll">
          <table class="auction-table">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Bidder</th>
                <th>Total Savings</th>
                <th>Savings %</th>
              </tr>
            </thead>
            <tbody id="ranked-body">
              <tr><td colspan="4" class="empty-state">No bids yet</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Bid Stream -->
      <div class="table-section">
        <div class="bid-stream-header">
          <div class="bid-stream-title-section">
            <h2>Bid Stream</h2>
            <button id="bid-stream-filter-btn" class="btn btn-sm btn-outline-secondary">Filter by</button>
            <button id="bid-stream-sort-btn" class="btn btn-sm btn-outline-secondary">Sort by</button>
          </div>
          <div class="bid-stream-filter-dropdown" id="bid-stream-filter-dropdown" style="display: none;">
            <select id="bid-stream-filter-type" class="bid-filter-select">
              <option value="all">All Bids</option>
              <option value="bidder">By Bidder</option>
              <option value="line_item">By Line Item</option>
            </select>
            <select id="bid-stream-filter-value" class="bid-filter-select" style="display: none;">
              <option value="">Select...</option>
            </select>
          </div>
          <div class="bid-stream-sort-dropdown" id="bid-stream-sort-dropdown" style="display: none;">
            <select id="bid-stream-sort-select" class="bid-filter-select">
              <option value="time-desc">Time (Newest First)</option>
              <option value="time-asc">Time (Oldest First)</option>
              <option value="bidder-asc">Bidder (A-Z)</option>
              <option value="bidder-desc">Bidder (Z-A)</option>
              <option value="amount-desc">Amount (High to Low)</option>
              <option value="amount-asc">Amount (Low to High)</option>
            </select>
          </div>
          <div class="bid-stream-actions">
            <button id="delete-bid-btn" class="btn btn-sm btn-outline-danger" disabled>Delete Selected</button>
          </div>
        </div>
        <div class="table-scroll">
          <table class="auction-table">
            <thead>
              <tr>
                <th>Bid ID</th>
                <th>Time</th>
                <th>Bidder</th>
                <th>Line Item #</th>
                <th>Line Item Name</th>
                <th>Bid Amount</th>
              </tr>
            </thead>
            <tbody id="bid-stream-body">
              <tr><td colspan="6" class="empty-state">No bids yet</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- Dependencies -->
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>
  <script src="/auction-graphs.js"></script>
  <script src="/messages.js"></script>

  <script>
    // --- Utilities ---
    const currencySymbols = { GBP:'£', USD:'$', EUR:'€', CAD:'$', AUD:'$', NZD:'$', CHF:'CHF', JPY:'¥', CNY:'¥', INR:'₹', SEK:'kr', NOK:'kr', DKK:'kr', PLN:'zł', ZAR:'R' };
    function fmtMoney(n, symbol){
      try { return `${symbol}${Number(n).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`; } catch { return `${symbol}${n}`; }
    }
    function pad(n){ return String(n).padStart(2,'0'); }
    function formatHMS(ms){
      const s = Math.max(0, Math.floor(ms/1000));
      const hh = pad(Math.floor(s/3600));
      const mm = pad(Math.floor((s%3600)/60));
      const ss = pad(s%60);
      return `${hh}:${mm}:${ss}`;
    }
    function formatHM(ms){
      const s = Math.max(0, Math.floor(ms/1000));
      const hh = Math.floor(s/3600);
      const mm = Math.floor((s%3600)/60);
      if(hh > 0) return `${hh}h ${mm}m`;
      return `${mm}m`;
    }
    function formatStartsIn(ms){
      if(ms <= 0) return "Starts now";
      const s = Math.floor(ms/1000);
      const days = Math.floor(s / 86400);
      const hours = Math.floor((s % 86400) / 3600);
      const minutes = Math.floor((s % 3600) / 60);
      if(days > 0) return `Starts in ${days} day${days > 1 ? 's' : ''}`;
      if(hours > 0) return `Starts in ${hours} hour${hours > 1 ? 's' : ''}`;
      if(minutes > 0) return `Starts in ${minutes} minute${minutes > 1 ? 's' : ''}`;
      return "Starting soon";
    }
    function getRandomColor(seed) {
      // Add eventId to seed to make colors random per event
      const fullSeed = eventId ? `${seed}-${eventId}` : seed;
      
      // Generate a consistent pastel color based on seed string
      let hash = 0;
      for(let i=0; i<fullSeed.length; i++) {
        hash = fullSeed.charCodeAt(i) + ((hash << 5) - hash);
      }
      
      // Get hue from hash, but exclude green range (90-150°) to avoid baseline color
      // Baseline is green: rgba(34, 197, 94, 0.5) ≈ hsl(142, 70%, 45%)
      let h = Math.abs(hash) % 360;
      
      // If in green range, shift to another color
      if (h >= 90 && h <= 150) {
        // Shift to red/orange range (0-60) or blue/purple range (200-280)
        h = (h < 120) ? (h - 90) : (h + 80);
      }
      
      return `hsl(${h}, 70%, 60%)`;
    }

    // --- Page state ---
    let eventId = null;
    let eventData = null;
    let currencySymbol = '£';
    let auctionStart = null;
    let auctionDurationMs = 0;
    let auctionEnd = null;
    let auctionLive = false;
    let auctionPaused = false;
    let extensionCount = 0; // Track number of extensions triggered
    // Chart.js chart handled by AuctionGraphs module

    // Data stores
    let allBids = []; // all bids loaded or received live
    let openingBids = []; // injected opening bids from supplier assignments
    let biddersMap = new Map(); // bidderId -> { user_name, bids: [{time, weightedBid, savings}] }
    let bidderTotals = new Map(); // bidderId -> { user_name, points: [{x, y}] } for graph
    let baselineMap = new Map(); // line_item_id -> { ext_baseline, ext_quantity, item_number, item_name }
    
    // Filter state
    let currentFilter = { type: 'all', id: null }; // { type: 'all' | 'lot' | 'line_item', id: number | null }
    let lotsData = []; // Array of lots with their line items
    
    // Bid stream filter state (independent from chart filter)
    let bidStreamFilter = { type: 'all', value: null }; // { type: 'all' | 'bidder' | 'line_item', value: string | number | null }
    
    // Bid stream sort state
    let bidStreamSort = 'time-desc'; // Default: time descending (newest first)

    // --- DOM elements ---
    const auctionTitleEl = document.getElementById('auction-title');
    const auctionStatusBadge = document.getElementById('auction-status-badge');
    const timeMainEl = document.getElementById('time-main');
    const timeSubEl = document.getElementById('time-sub');
    const pauseResumeBtn = document.getElementById('pause-resume-btn');
    const rankedBody = document.getElementById('ranked-body');

    // Chart config handled by AuctionGraphs module

    // Track last total baseline for chart reinit
    let lastTotalBaseline = null;

    // --- Helper function to update auction status badge ---
    function setAuctionStatus(isLive) {
      if (!auctionStatusBadge) return;
      
      if (isLive) {
        auctionStatusBadge.textContent = 'LIVE';
        auctionStatusBadge.classList.remove('offline');
        auctionStatusBadge.classList.add('live');
      } else {
        auctionStatusBadge.textContent = 'OFFLINE';
        auctionStatusBadge.classList.remove('live');
        auctionStatusBadge.classList.add('offline');
      }
    }

    // --- Helper function to update pause/resume button ---
    function setPauseButtonState(isPaused) {
      if (isPaused) {
        pauseResumeBtn.textContent = 'RESUME';
        pauseResumeBtn.classList.remove('paused');
        pauseResumeBtn.classList.add('resumed');
      } else {
        pauseResumeBtn.textContent = 'PAUSE';
        pauseResumeBtn.classList.remove('resumed');
        pauseResumeBtn.classList.add('paused');
      }
    }

    // --- Auction time management ---
    function updateCountdown(){
      if(!auctionStart) return;
      
      const now = new Date();
      if(!auctionLive){
        const msUntilStart = auctionStart - now;
        if(msUntilStart > 0){
          timeMainEl.textContent = formatStartsIn(msUntilStart);
          timeSubEl.textContent = `Starts at ${auctionStart.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}`;
          pauseResumeBtn.disabled = true;
          setPauseButtonState(auctionPaused);
        } else {
          // Auction just started
          auctionLive = true;
          pauseResumeBtn.disabled = false;
          setPauseButtonState(auctionPaused); // Use actual pause state from DB
          
          // Initialize auction end time if not already set
          if (!auctionEnd) {
            auctionEnd = new Date(auctionStart.getTime() + auctionDurationMs);
            // Update the server with the calculated end time
            initializeAuctionEndTime();
          }
          
          timeSubEl.textContent = '';
        }
      }
      // Note: Live auction countdown is now handled by server time_sync events
      // This function only handles pre-auction countdown
    }

    // === Update countdown display from server ===
    function updateCountdownFromServer(secondsRemaining, isPaused) {
      if (!timeMainEl) return;
      
      if (secondsRemaining === null || secondsRemaining === undefined) {
        timeMainEl.textContent = 'Waiting for auction to start...';
        setAuctionStatus(false);
        return;
      }
      
      if (secondsRemaining <= 0) {
        timeMainEl.textContent = 'Auction ended';
        timeSubEl.textContent = '';
        pauseResumeBtn.disabled = true;
        if (auctionLive) {
          // Auction just ended
          console.log(`🏁 Auction ended: "${eventData?.title || 'Unknown Event'}"`);
        }
        auctionLive = false;
        auctionPaused = true;
        setPauseButtonState(false);
        setAuctionStatus(false);
        return;
      }
      
      // Auction is running or paused - enable controls
      if (!auctionLive) {
        auctionLive = true;
        pauseResumeBtn.disabled = false;
        setAuctionStatus(true);
        // Console notification when auction goes live
        console.log(`🚀 Auction is now LIVE: "${eventData?.title || 'Unknown Event'}"`);
      }
      
      const msLeft = secondsRemaining * 1000;
      
      if (isPaused) {
        timeMainEl.textContent = `⏸️ Paused: ${formatHMS(msLeft)} remaining`;
      } else {
        timeMainEl.textContent = `Time left: ${formatHMS(msLeft)}`;
      }
    }    // --- Initialize auction end time on server when auction goes live ---
    async function initializeAuctionEndTime() {
      try {
        await authFetch(`/events/${eventId}/initialize-end-time`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            auction_end_time: auctionEnd.toISOString()
          })
        });
      } catch(e) {
        console.error('Error initializing auction end time:', e);
      }
    }

    // --- Bid savings computation ---
    // savings = (lineItem.ext_baseline - (bid.amount * bid.weighting * lineItem.ext_quantity))
    function computeBidSavings(bid){
      if(!bid.line_item_id) return 0;
      const baselineObj = baselineMap.get(bid.line_item_id);
      if(!baselineObj) return 0;
      const extBaseline = baselineObj.ext_baseline || 0;
      const extQuantity = baselineObj.ext_quantity || 1;
      const weighting = (typeof bid.weighting === 'number') ? bid.weighting : 1;
      const weightedBid = bid.amount * weighting * extQuantity;
      return extBaseline - weightedBid;
    }
    function computeWeightedBid(bid){
      const weighting = (typeof bid.weighting === 'number') ? bid.weighting : 1;
      return bid.amount * weighting;
    }

    // --- Load event and baseline data ---
    async function loadEvent(){
      console.log('=== loadEvent() starting ===');
      const res = await authFetch(`/events/${eventId}`);
      eventData = await res.json();
      auctionTitleEl.textContent = eventData.title || 'Live Auction';

      const code = (eventData.currency || 'GBP').toUpperCase();
      currencySymbol = currencySymbols[code] || code || '£';

      console.log('eventData.auction_time:', eventData.auction_time);
      if(eventData.auction_time){
        auctionStart = new Date(eventData.auction_time);
        console.log('auctionStart set to:', auctionStart);
      } else {
        console.warn('⚠️ No auction_time in eventData!');
      }
      
      // Use auction_end_time if available, otherwise calculate from duration
      if (eventData.auction_end_time) {
        auctionEnd = new Date(eventData.auction_end_time);
        auctionDurationMs = auctionEnd - auctionStart;
      } else {
        auctionDurationMs = (Number(eventData.auction_duration) || 60) * 60 * 1000;
      }
      
      // Set initial pause state from database
      auctionPaused = eventData.type === 'paused';
      auctionLive = false;
      pauseResumeBtn.disabled = true;
      setPauseButtonState(auctionPaused);

      // Display extension settings
      const extensionTime = Number(eventData.extension_time) || 0;
      const extensionThreshold = Number(eventData.extension_threshold) || 0;
      const extensionSettingsEl = document.getElementById('extension-settings');
      if (extensionSettingsEl) {
        extensionSettingsEl.textContent = `Reset to ${extensionTime}s if bid in last ${extensionThreshold}s`;
      }

      // Load baseline data for line items (if available)
      baselineMap.clear();
      if(Array.isArray(eventData.line_items)){
        for(const li of eventData.line_items){
          if(li.id){
            baselineMap.set(li.id, {
              ext_baseline: Number(li.ext_baseline) || 0,
              ext_quantity: Number(li.ext_quantity) || 1,
              item_number: li.item_number,
              item_name: li.item_name,
              lot_id: li.lot_id
            });
          }
        }
      }

      // Load lots data for filter dropdown
      await loadLotsAndPopulateFilter();

      // Inject opening bids for suppliers before auction begins, if present
      // This allows pre-assigned opening prices to display as first bids
      const supplierAssignments = eventData.supplier_assignments || eventData.assigned_suppliers;
      if (Array.isArray(supplierAssignments)) {
        for (const sa of supplierAssignments) {
          if (sa.opening_bid !== undefined && sa.opening_bid !== null) {
            openingBids.push({
              id: `opening-${sa.supplier_id}-${sa.line_item_id}`,
              user_id: sa.supplier_id,
              user_name: sa.supplier_name || `Supplier ${sa.supplier_id}`,
              line_item_id: sa.line_item_id,
              amount: Number(sa.opening_bid) || 0,
              weighting: Number(sa.weighting) || 1,
              created_at: eventData.auction_time || new Date().toISOString()
            });
          }
        }
        console.log('Loaded', openingBids.length, 'opening bids from supplier assignments');
      }
    }

    // --- Load stats ---
    async function loadStats(){
      try {
        const res = await authFetch(`/events/${eventId}/stats`);
        const s = await res.json();
        document.getElementById('total-bids-value').textContent = s.total_bids || 0;
        document.getElementById('bidders-connected-value').textContent = `${s.bidders_connected || 0} / ${s.total_bidders || 0}`;
        document.getElementById('extensions-value').textContent = extensionCount;
      } catch(e) {
        console.error('Stats error', e);
      }
    }

    // --- Load lots and populate filter dropdown ---
    async function loadLotsAndPopulateFilter() {
      try {
        const res = await authFetch(`/events/${eventId}/lots`);
        lotsData = await res.json();
        
        const menu = document.getElementById('filter-menu');
        if (!menu) return;
        
        // Clear existing menu
        menu.innerHTML = '<div class="filter-option selected" data-value="all">Total Savings</div>';
        
        // Group line items by lot
        const lineItemsByLot = new Map();
        baselineMap.forEach((li, lineItemId) => {
          const lotId = li.lot_id || 'unassigned';
          if (!lineItemsByLot.has(lotId)) {
            lineItemsByLot.set(lotId, []);
          }
          lineItemsByLot.get(lotId).push({ id: lineItemId, ...li });
        });
        
        // Add lots with their line items
        if (lotsData.length > 0) {
          menu.innerHTML += '<div class="filter-divider"></div>';
          
          lotsData.forEach(lot => {
            const lotItems = lineItemsByLot.get(lot.id) || [];
            
            // Sort line items by item_number
            lotItems.sort((a, b) => {
              const numA = parseInt(a.item_number) || 0;
              const numB = parseInt(b.item_number) || 0;
              return numA - numB;
            });
            
            // Add lot parent
            const lotDiv = document.createElement('div');
            lotDiv.className = 'filter-lot-parent';
            lotDiv.dataset.lotId = lot.id;
            lotDiv.innerHTML = `
              <span>${lot.title || `Lot ${lot.id}`}</span>
              <svg class="lot-arrow" viewBox="0 0 10 10">
                <path fill="currentColor" d="M2 1 L8 5 L2 9 Z"/>
              </svg>
            `;
            menu.appendChild(lotDiv);
            
            // Add line items container
            const childrenDiv = document.createElement('div');
            childrenDiv.className = 'filter-lot-children';
            childrenDiv.dataset.lotId = lot.id;
            
            // Add lot-level option (view all items in this lot)
            const lotOption = document.createElement('div');
            lotOption.className = 'filter-line-item';
            lotOption.dataset.value = `lot-${lot.id}`;
            lotOption.innerHTML = `<em>All items in this lot</em>`;
            childrenDiv.appendChild(lotOption);
            
            // Add individual line items
            lotItems.forEach(li => {
              const lineDiv = document.createElement('div');
              lineDiv.className = 'filter-line-item';
              lineDiv.dataset.value = `line-${li.id}`;
              const itemLabel = li.item_number ? `#${li.item_number}` : `Item ${li.id}`;
              const itemName = li.item_name ? ` - ${li.item_name}` : '';
              lineDiv.textContent = `${itemLabel}${itemName}`;
              childrenDiv.appendChild(lineDiv);
            });
            
            menu.appendChild(childrenDiv);
          });
        }
        
        // Setup event handlers
        setupFilterDropdown();
        
      } catch (e) {
        console.error('Error loading lots:', e);
      }
    }

    // --- Apply filter based on current selection ---
    function getFilteredLineItemIds() {
      if (currentFilter.type === 'all') {
        return null; // No filter, include all
      } else if (currentFilter.type === 'lot') {
        // Return all line item IDs for this lot
        const lineItemIds = [];
        baselineMap.forEach((li, lineItemId) => {
          if (li.lot_id === currentFilter.id) {
            lineItemIds.push(lineItemId);
          }
        });
        return lineItemIds;
      } else if (currentFilter.type === 'line_item') {
        // Return only this line item ID
        return [currentFilter.id];
      }
      return null;
    }

    // --- Filter bids based on current filter ---
    function getFilteredBids() {
      const filterIds = getFilteredLineItemIds();
      console.log('getFilteredBids - filterIds:', filterIds);
      if (!filterIds) {
        console.log('No filter, returning all', allBids.length, 'bids');
        return allBids; // No filter
      }
      
      const filtered = allBids.filter(bid => filterIds.includes(bid.line_item_id));
      console.log('Filtered to', filtered.length, 'bids from line items:', filterIds);
      return filtered;
    }

    // --- Filter baseline map based on current filter ---
    function getFilteredBaselineMap() {
      const filterIds = getFilteredLineItemIds();
      console.log('getFilteredBaselineMap - filterIds:', filterIds);
      if (!filterIds) {
        console.log('No filter, returning full baseline map with', baselineMap.size, 'items');
        return baselineMap; // No filter
      }
      
      const filtered = new Map();
      filterIds.forEach(id => {
        if (baselineMap.has(id)) {
          filtered.set(id, baselineMap.get(id));
        }
      });
      console.log('Filtered baseline to', filtered.size, 'items');
      return filtered;
    }

    // --- Setup custom dropdown handlers ---
    function setupFilterDropdown() {
      const dropdown = document.getElementById('filter-dropdown');
      const selected = document.getElementById('filter-selected');
      const menu = document.getElementById('filter-menu');
      const selectedText = document.getElementById('filter-selected-text');
      
      if (!dropdown || !selected || !menu || !selectedText) return;
      
      // Toggle dropdown
      selected.addEventListener('click', (e) => {
        e.stopPropagation();
        const isOpen = menu.style.display === 'block';
        menu.style.display = isOpen ? 'none' : 'block';
        dropdown.classList.toggle('open', !isOpen);
      });
      
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!dropdown.contains(e.target)) {
          menu.style.display = 'none';
          dropdown.classList.remove('open');
        }
      });
      
      // Handle lot parent clicks (expand/collapse)
      menu.addEventListener('click', (e) => {
        const lotParent = e.target.closest('.filter-lot-parent');
        if (lotParent) {
          e.stopPropagation();
          const lotId = lotParent.dataset.lotId;
          const children = menu.querySelector(`.filter-lot-children[data-lot-id="${lotId}"]`);
          if (children) {
            const isExpanded = children.classList.contains('expanded');
            children.classList.toggle('expanded', !isExpanded);
            lotParent.classList.toggle('expanded', !isExpanded);
          }
        }
      });
      
      // Handle option selection
      menu.addEventListener('click', (e) => {
        const option = e.target.closest('.filter-option, .filter-line-item');
        if (option && option.dataset.value) {
          e.stopPropagation();
          
          // Update selection
          menu.querySelectorAll('.filter-option, .filter-line-item').forEach(opt => {
            opt.classList.remove('selected');
          });
          option.classList.add('selected');
          
          // Update displayed text
          selectedText.textContent = option.textContent.trim();
          
          // Close menu
          menu.style.display = 'none';
          dropdown.classList.remove('open');
          
          // Trigger filter change
          onFilterChange(option.dataset.value);
        }
      });
    }

    // --- Handle filter dropdown change ---
    function onFilterChange(value) {
      
      console.log('Filter changed to:', value);
      
      if (value === 'all') {
        currentFilter = { type: 'all', id: null };
      } else if (value.startsWith('lot-')) {
        currentFilter = { type: 'lot', id: parseInt(value.replace('lot-', '')) };
      } else if (value.startsWith('line-')) {
        currentFilter = { type: 'line_item', id: parseInt(value.replace('line-', '')) };
      }
      
      console.log('Current filter:', currentFilter);
      
      // Reprocess and update display with filtered data
      processBids();
      rebuildBidderTotalsFromHistory();
      updateChartAndTable();
    }

    // --- Load bids ---
    async function loadBids(){
      try {
        console.log('=== loadBids() starting ===');
        console.log('auctionStart before loading bids:', auctionStart);
        console.log('openingBids count:', openingBids.length);
        
        const res = await authFetch(`/events/${eventId}/bids`);
        const bids = await res.json();
        console.log('Loaded bids from server:', bids.length);
        console.log('Sample bid structure:', bids[0]);
        allBids = (bids || []);
        
        // Prepend opening bids if they exist and aren't already present
        const existingIds = new Set(allBids.map(b => String(b.id)));
        let addedOpeningBids = 0;
        openingBids.forEach(ob => {
          if (!existingIds.has(String(ob.id))) {
            allBids.unshift(ob);
            addedOpeningBids++;
          }
        });
        console.log('Added', addedOpeningBids, 'opening bids to allBids');
        console.log('Total allBids count:', allBids.length);
        
        // FALLBACK: If no auction_time was set, use the earliest bid timestamp as the start time
        // This ensures opening bids are at x=0 and subsequent bids are relative to that
        if (!auctionStart && allBids.length > 0) {
          const earliestBid = allBids.reduce((earliest, bid) => {
            const bidTime = new Date(bid.created_at);
            return (!earliest || bidTime < earliest) ? bidTime : earliest;
          }, null);
          
          if (earliestBid) {
            auctionStart = earliestBid;
            console.log('⚠️ No auction_time set - using earliest bid as auctionStart:', auctionStart);
            console.log('   This means opening bids will be at x=0 and all other bids relative to this time');
          }
        }
        
        processBids();
        console.log('About to call rebuildBidderTotalsFromHistory, auctionStart:', auctionStart);
        rebuildBidderTotalsFromHistory(); // Rebuild totals once from history
        console.log('After rebuildBidderTotalsFromHistory, bidderTotals.size:', bidderTotals.size);
        updateChartAndTable();
        console.log('=== loadBids() complete ===');
      } catch(e) {
        console.error('Bids error', e);
      }
    }

    // Rebuild bidderTotals from existing bids (called ONLY on page load)
    function rebuildBidderTotalsFromHistory() {
      console.log('Rebuilding bidder totals from historical bids...', 'Filter:', currentFilter);
      
      // Safety check - need auction start time to calculate elapsed time
      if (!auctionStart) {
        console.warn('⚠️ Cannot rebuild bidder totals - auction start time not set yet');
        return;
      }
      
      // Always clear and rebuild from scratch
      bidderTotals.clear();
      
      // Get filtered bids and baseline
      const filteredBids = getFilteredBids();
      const filteredBaseline = getFilteredBaselineMap();
      
      console.log('All bids count:', allBids.length);
      console.log('Filtered bids count:', filteredBids.length);
      console.log('Filtered baseline count:', filteredBaseline.size);
      console.log('Auction start time:', auctionStart);
      
      // Group all bids by user
      const userBids = new Map(); // user_id -> array of all their bids
      
      for (const bid of filteredBids) {
        if (!bid.user_id || !bid.created_at || bid.amount === undefined) continue;
        if (!userBids.has(bid.user_id)) {
          userBids.set(bid.user_id, []);
        }
        userBids.get(bid.user_id).push(bid);
        console.log(`Added bid ${bid.id} for user ${bid.user_id} (${bid.user_name})`);
      }
      
      console.log('Users with bids:', Array.from(userBids.keys()));
      
      // For each user, reconstruct their bid history
      userBids.forEach((bids, userId) => {
        // Sort bids chronologically
        bids.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
        
        const userName = bids[0].user_name || `Bidder ${userId}`;
        const points = [];
        
        // Track unique submission times (rounded to second to group bulk submissions)
        const submissionTimes = new Set();
        
        for (const bid of bids) {
          const timestamp = new Date(bid.created_at);
          const roundedTime = Math.floor(timestamp.getTime() / 1000) * 1000;
          submissionTimes.add(roundedTime);
        }
        
        // For each submission time, calculate the total based on latest bids for each line item
        const sortedTimes = Array.from(submissionTimes).sort((a, b) => a - b);
        
        for (const timestamp of sortedTimes) {
          const createdAt = new Date(timestamp);
          const elapsedMs = auctionStart ? (createdAt - auctionStart) : 0;
          const elapsedMinutes = elapsedMs / 60000;
          
          console.log(`Processing timestamp ${createdAt.toISOString()}, elapsed: ${elapsedMinutes} min`);
          
          // Get the state of all line items at this point in time
          // For each line item this user has bid on, find the most recent bid up to this time
          const lineItemState = new Map(); // line_item_id -> latest bid
          
          // Compare to end of second (timestamp + 999ms) to include all bids in that second
          const timestampEndOfSecond = timestamp + 999;
          
          console.log(`  Checking ${bids.length} bids against timestamp ${timestampEndOfSecond} (end of second)`);
          for (const bid of bids) {
            const bidTime = new Date(bid.created_at).getTime();
            console.log(`    Bid ${bid.id} time: ${bidTime}, comparing to ${timestampEndOfSecond}, bidTime <= timestamp: ${bidTime <= timestampEndOfSecond}`);
            if (bidTime <= timestampEndOfSecond) {
              // This bid was placed at or before this submission time
              const existing = lineItemState.get(bid.line_item_id);
              if (!existing || new Date(existing.created_at).getTime() < bidTime) {
                lineItemState.set(bid.line_item_id, bid);
                console.log(`    ✓ Added/updated line item ${bid.line_item_id} in state`);
              }
            }
          }
          
          // Calculate total from this state (using filtered baseline)
          let total = 0;
          let itemsIncluded = 0;
          console.log(`  Line item state has ${lineItemState.size} items`);
          lineItemState.forEach((bid, lineItemId) => {
            console.log(`  Checking line item ${lineItemId}, exists in baseline:`, filteredBaseline.has(lineItemId));
            const li = filteredBaseline.get(lineItemId);
            if (!li) {
              console.log('  ⚠️ Skipping line item not in filter:', lineItemId);
              return; // Skip if not in filtered baseline
            }
            const extQuantity = li.ext_quantity || 1;
            const weighting = Number(bid.weighting) || 1;
            const extendedBid = Number(bid.amount) * weighting * extQuantity;
            total += extendedBid;
            itemsIncluded++;
            console.log(`  ✓ Line item ${lineItemId}: ${bid.amount} * ${weighting} * ${extQuantity} = ${extendedBid}`);
          });
          
          console.log(`  Total: ${total}, Items included: ${itemsIncluded}`);
          
          if (itemsIncluded > 0) {
            const point = {
              x: Math.max(0, elapsedMinutes), // Ensure non-negative
              y: total,
              isOpening: elapsedMinutes <= 0
            };
            points.push(point);
            console.log(`  Created point:`, point);
          }
        }
        
        // Add bidder to bidderTotals if they have points
        if (points.length > 0) {
          bidderTotals.set(userId, {
            user_name: userName,
            points: points
          });
          console.log(`✓ Added bidder ${userName} with ${points.length} points`);
        } else {
          console.log(`✗ No points for bidder ${userName}`);
        }
      });
      
      console.log('Final bidder totals:', Array.from(bidderTotals.entries()).map(([id, data]) => ({
        userId: id,
        userName: data.user_name,
        pointCount: data.points.length,
        points: data.points
      })));
    }

    // --- Process bids for chart and ranking ---
    // Organize bids by bidder with time elapsed and savings
    function processBids(){
      biddersMap.clear();

      // Get filtered data
      const filteredBids = getFilteredBids();
      const filteredBaseline = getFilteredBaselineMap();

      // Sort bids by created_at ascending for time series
      filteredBids.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));

      // NOTE: bidderTotals is NOT rebuilt here - it's only populated on initial page load
      // and updated via socket events (bidder_total_update) to avoid recreating multiple
      // points per line item bid

      for(const bid of filteredBids){
        if(!bid.user_id) continue;
        if(!auctionStart) continue;
        const bidderId = bid.user_id;
        const bidderName = bid.user_name || `Bidder ${bidderId}`;
        
        console.log(`Processing bid ${bid.id}: user_id=${bidderId}, user_name="${bid.user_name}", organisation_name="${bid.organisation_name}"`);

        // Calculate time elapsed in minutes from auctionStart
        const createdAt = new Date(bid.created_at);
        const elapsedMs = createdAt - auctionStart;
        // Allow opening bids even if before auction start
        if (elapsedMs < 0 && !(bid.id && bid.id.startsWith('opening-'))) continue;

        const elapsedMinutes = elapsedMs / 60000;

        // Compute extendedBid: amount * weighting * ext_quantity (using filtered baseline)
        const weighting = (typeof bid.weighting === 'number') ? bid.weighting : 1;
        const extQuantity = filteredBaseline.get(bid.line_item_id)?.ext_quantity || 1;
        const extendedBid = bid.amount * weighting * extQuantity;
        
        // Compute savings using filtered baseline
        const baselineObj = filteredBaseline.get(bid.line_item_id);
        const savings = baselineObj ? (baselineObj.ext_baseline - extendedBid) : 0;

        if(!biddersMap.has(bidderId)){
          biddersMap.set(bidderId, {
            user_name: bidderName,
            bids: []
          });
        }
        biddersMap.get(bidderId).bids.push({
          time: elapsedMinutes,
          extendedBid,
          savings,
          line_item_id: bid.line_item_id,
          rawBid: bid
        });
      }
    }

    // --- Update Chart and Ranked Table ---
    function updateChartAndTable(){
      // Get filtered baseline for calculations
      const filteredBaseline = getFilteredBaselineMap();
      
      // Compute total baseline for filtered line items (sum of ext_baseline only)
      const totalBaseline = Array.from(filteredBaseline.values()).reduce((acc, li) => acc + (li.ext_baseline || 0), 0);

      console.log('updateChartAndTable - totalBaseline:', totalBaseline);
      console.log('updateChartAndTable - bidderTotals size:', bidderTotals.size);
      console.log('updateChartAndTable - bidderTotals data:', Array.from(bidderTotals.entries()).map(([id, data]) => ({
        id, 
        name: data.user_name, 
        pointCount: data.points.length
      })));

      // Only reinitialize chart if the baseline has changed
      if (lastTotalBaseline === null || totalBaseline !== lastTotalBaseline) {
        lastTotalBaseline = totalBaseline;
        console.log('Baseline changed, reinitializing chart:', totalBaseline);
        AuctionGraphs.initChart('bid-chart', totalBaseline, currencySymbol);
      }
      
      console.log('Calling AuctionGraphs.showSavingsByBidder with', bidderTotals.size, 'bidders');
      AuctionGraphs.showSavingsByBidder(bidderTotals, currencySymbol, totalBaseline, null, eventId);

      // Compute rankings
      const ranking = [];
      biddersMap.forEach((bidder, bidderId) => {
        // Sum total savings and total weighted bid for last bid
        const totalSavings = bidder.bids.reduce((acc, b) => acc + b.savings, 0);
        const lastWeightedBid = bidder.bids.length ? bidder.bids[bidder.bids.length - 1].weightedBid : 0;
        const savingsPercent = totalBaseline > 0 ? (totalSavings / totalBaseline) * 100 : 0;
        ranking.push({
          user_id: bidderId,
          user_name: bidder.user_name,
          totalSavings,
          savingsPercent
        });
      });
      ranking.sort((a,b) => b.totalSavings - a.totalSavings);

      // Render ranked table
      if(ranking.length === 0){
        rankedBody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No bids yet</td></tr>';
      } else {
        rankedBody.innerHTML = ranking.map((r,i) => {
          const bidderColor = AuctionGraphs.getColorForBidder(r.user_name, eventId);
          return `<tr>
            <td>${i+1}</td>
            <td><span class="bidder-name" style="color: ${bidderColor};">${r.user_name}</span></td>
            <td>${fmtMoney(r.totalSavings, currencySymbol)}</td>
            <td>${r.savingsPercent.toFixed(2)}%</td>
          </tr>`;
        }).join('');
      }
      updateBidStream();
    }

    // --- Bid Stream Table update ---
    let selectedBidId = null;
    
    function updateBidStream() {
      const tbody = document.getElementById('bid-stream-body');
      if(!tbody) return;
      
      // Always use ALL bids for bid stream (not filtered by chart filter)
      let displayBids = [...allBids];
      
      // Apply bid stream specific filter
      if (bidStreamFilter.type === 'bidder' && bidStreamFilter.value) {
        displayBids = displayBids.filter(b => b.user_id == bidStreamFilter.value);
      } else if (bidStreamFilter.type === 'line_item' && bidStreamFilter.value) {
        displayBids = displayBids.filter(b => b.line_item_id == bidStreamFilter.value);
      }
      
      if(displayBids.length === 0){
        tbody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No bids yet</td></tr>';
        return;
      }
      
      // Apply sorting
      switch(bidStreamSort) {
        case 'time-desc':
          displayBids.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
          break;
        case 'time-asc':
          displayBids.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
          break;
        case 'bidder-asc':
          displayBids.sort((a,b) => (a.user_name || '').localeCompare(b.user_name || ''));
          break;
        case 'bidder-desc':
          displayBids.sort((a,b) => (b.user_name || '').localeCompare(a.user_name || ''));
          break;
        case 'amount-desc':
          displayBids.sort((a,b) => (b.amount || 0) - (a.amount || 0));
          break;
        case 'amount-asc':
          displayBids.sort((a,b) => (a.amount || 0) - (b.amount || 0));
          break;
        default:
          displayBids.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
      }
      
      tbody.innerHTML = displayBids.map(b=>{
        const li = baselineMap.get(b.line_item_id);
        const lineNum = li?.item_number || b.line_item_id || '-';
        const lineName = li?.item_name || '-';
        let timeInAuction = '-';
        if (auctionStart) {
          const elapsedMs = new Date(b.created_at) - auctionStart;
          const mins = Math.floor(elapsedMs / 60000);
          const secs = Math.floor((elapsedMs % 60000) / 1000);
          timeInAuction = `${mins}m ${secs}s`;
        }
        const bidAmount = fmtMoney(b.amount || 0, currencySymbol);
        const isOpeningBid = String(b.id).startsWith('opening-');
        return `<tr class="bid-row ${isOpeningBid ? 'opening-bid' : 'selectable-bid'}" data-bid-id="${b.id}" data-bid-amount="${b.amount}" data-is-opening="${isOpeningBid}">
          <td>${b.id}</td>
          <td>${timeInAuction}</td>
          <td>${b.user_name || 'Unknown'}</td>
          <td>${lineNum}</td>
          <td>${lineName}</td>
          <td>${bidAmount}</td>
        </tr>`;
      }).join('');
      
      // Add click handlers to rows
      const selectableRows = tbody.querySelectorAll('.selectable-bid');
      console.log(`Found ${selectableRows.length} selectable bid rows`);
      selectableRows.forEach(row => {
        row.addEventListener('click', () => {
          console.log('Row clicked:', row.dataset.bidId);
          selectBidRow(row);
        });
      });
    }
    
    function selectBidRow(row) {
      console.log('selectBidRow called for:', row.dataset.bidId);
      // Remove previous selection
      document.querySelectorAll('.bid-row.selected').forEach(r => r.classList.remove('selected'));
      
      // Select this row
      row.classList.add('selected');
      selectedBidId = row.dataset.bidId;
      
      // Enable delete button
      document.getElementById('delete-bid-btn').disabled = false;
    }
    
    // --- Setup bid stream filter ---
    function setupBidStreamFilter() {
      const filterBtn = document.getElementById('bid-stream-filter-btn');
      const filterDropdown = document.getElementById('bid-stream-filter-dropdown');
      const filterType = document.getElementById('bid-stream-filter-type');
      const filterValue = document.getElementById('bid-stream-filter-value');
      
      const sortBtn = document.getElementById('bid-stream-sort-btn');
      const sortDropdown = document.getElementById('bid-stream-sort-dropdown');
      const sortSelect = document.getElementById('bid-stream-sort-select');
      
      if (!filterBtn || !filterDropdown || !filterType || !filterValue) return;
      
      // Toggle filter dropdown visibility
      filterBtn.addEventListener('click', () => {
        const isVisible = filterDropdown.style.display === 'block';
        filterDropdown.style.display = isVisible ? 'none' : 'block';
        // Close sort dropdown when opening filter
        if (sortDropdown) sortDropdown.style.display = 'none';
      });
      
      // Toggle sort dropdown visibility
      if (sortBtn && sortDropdown) {
        sortBtn.addEventListener('click', () => {
          const isVisible = sortDropdown.style.display === 'block';
          sortDropdown.style.display = isVisible ? 'none' : 'block';
          // Close filter dropdown when opening sort
          filterDropdown.style.display = 'none';
        });
      }
      
      // Handle sort change
      if (sortSelect) {
        sortSelect.addEventListener('change', () => {
          bidStreamSort = sortSelect.value;
          updateBidStream();
        });
      }
      
      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!filterBtn.contains(e.target) && !filterDropdown.contains(e.target)) {
          filterDropdown.style.display = 'none';
        }
        if (sortBtn && sortDropdown && !sortBtn.contains(e.target) && !sortDropdown.contains(e.target)) {
          sortDropdown.style.display = 'none';
        }
      });
      
      // Handle filter type change
      filterType.addEventListener('change', () => {
        const type = filterType.value;
        
        if (type === 'all') {
          filterValue.style.display = 'none';
          bidStreamFilter = { type: 'all', value: null };
          updateBidStream();
        } else if (type === 'bidder') {
          // Populate bidder dropdown
          populateBidderFilter();
          filterValue.style.display = 'inline-block';
        } else if (type === 'line_item') {
          // Populate line item dropdown
          populateLineItemFilter();
          filterValue.style.display = 'inline-block';
        }
      });
      
      // Handle filter value change
      filterValue.addEventListener('change', () => {
        const type = filterType.value;
        const value = filterValue.value;
        
        if (type === 'bidder') {
          bidStreamFilter = { type: 'bidder', value: value ? parseInt(value) : null };
        } else if (type === 'line_item') {
          bidStreamFilter = { type: 'line_item', value: value ? parseInt(value) : null };
        }
        
        updateBidStream();
      });
    }
    
    // --- Populate bidder filter options ---
    function populateBidderFilter() {
      const filterValue = document.getElementById('bid-stream-filter-value');
      if (!filterValue) return;
      
      // Get unique bidders from all bids
      const bidders = new Map();
      allBids.forEach(bid => {
        if (bid.user_id && bid.user_name) {
          bidders.set(bid.user_id, bid.user_name);
        }
      });
      
      // Populate dropdown
      filterValue.innerHTML = '<option value="">All Bidders</option>';
      Array.from(bidders.entries())
        .sort((a, b) => a[1].localeCompare(b[1]))
        .forEach(([id, name]) => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = name;
          filterValue.appendChild(option);
        });
      
      // Reset filter
      bidStreamFilter = { type: 'bidder', value: null };
      updateBidStream();
    }
    
    // --- Populate line item filter options ---
    function populateLineItemFilter() {
      const filterValue = document.getElementById('bid-stream-filter-value');
      if (!filterValue) return;
      
      // Get unique line items from baseline map
      const lineItems = [];
      baselineMap.forEach((li, id) => {
        lineItems.push({
          id: id,
          number: li.item_number,
          name: li.item_name
        });
      });
      
      // Sort by item number
      lineItems.sort((a, b) => {
        const numA = parseInt(a.number) || 0;
        const numB = parseInt(b.number) || 0;
        return numA - numB;
      });
      
      // Populate dropdown
      filterValue.innerHTML = '<option value="">All Line Items</option>';
      lineItems.forEach(li => {
        const option = document.createElement('option');
        option.value = li.id;
        const itemLabel = li.number ? `#${li.number}` : `Item ${li.id}`;
        const itemName = li.name ? ` - ${li.name}` : '';
        option.textContent = `${itemLabel}${itemName}`;
        filterValue.appendChild(option);
      });
      
      // Reset filter
      bidStreamFilter = { type: 'line_item', value: null };
      updateBidStream();
    }
    
    // --- Edit Selected Bid ---
    async function editSelectedBid() {
      console.log('editSelectedBid called, selectedBidId:', selectedBidId);
      if (!selectedBidId) return;
      
      const row = document.querySelector(`.bid-row[data-bid-id="${selectedBidId}"]`);
      if (!row) return;
      
      const currentAmount = row.dataset.bidAmount;
      const newAmount = prompt(`Edit bid amount (current: ${currencySymbol}${currentAmount}):`, currentAmount);
      if (newAmount === null || newAmount === '') return;
      
      const amount = parseFloat(newAmount);
      if (isNaN(amount) || amount <= 0) {
        console.error('Invalid bid amount entered');
        return;
      }

      try {
        const res = await authFetch(`/events/${eventId}/bids/${selectedBidId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ amount })
        });

        if (res.ok) {
          console.log('Bid updated successfully');
          selectedBidId = null;
          document.getElementById('delete-bid-btn').disabled = true;
          await loadBids();
          loadStats();
        } else {
          const error = await res.json();
          console.error('Failed to update bid:', error.error || 'Unknown error');
        }
      } catch (e) {
        console.error('Error updating bid:', e);
      }
    }

    // --- Delete Selected Bid ---
    async function deleteSelectedBid() {
      console.log('deleteSelectedBid called, selectedBidId:', selectedBidId);
      if (!selectedBidId) return;
      
      if (!confirm('Are you sure you want to delete this bid?')) return;

      try {
        const res = await authFetch(`/events/${eventId}/bids/${selectedBidId}`, {
          method: 'DELETE'
        });

        if (res.ok) {
          console.log('Bid deleted successfully');
          selectedBidId = null;
          document.getElementById('delete-bid-btn').disabled = true;
          await loadBids();
          loadStats();
        } else {
          const error = await res.json();
          console.error('Failed to delete bid:', error.error || 'Unknown error');
        }
      } catch (e) {
        console.error('Error deleting bid:', e);
      }
    }

    // --- Socket.IO integration ---
    let socket = null;
    function connectSocket(){
      const token = localStorage.getItem('token');
      socket = io(window.location.origin, {
        transports: ["websocket"],
        auth: { token },
        query: { event_id: eventId }
      });
      socket.emit('join_event', eventId);

      // SERVER AUTHORITATIVE TIME - Critical for consistency across all users
      socket.on('time_sync', (data) => {
        const { secondsRemaining, isPaused: serverPaused, endTime, elapsedSeconds } = data;
        
        // Update pause state from server
        // Track pause state changes
        if (serverPaused !== auctionPaused) {
          auctionPaused = serverPaused;
          setPauseButtonState(serverPaused);
        }
        
        // Update end time if provided
        if (endTime) {
          auctionEnd = new Date(endTime);
        }
        
        // Update countdown display with server's authoritative time
        updateCountdownFromServer(secondsRemaining, serverPaused);
        
        // Update x-axis with server's elapsed time
        if (elapsedSeconds !== null && elapsedSeconds !== undefined) {
          AuctionGraphs.updateXAxisFromServer(elapsedSeconds);
        }
      });

      socket.on('bid_update', (bid) => {
        if(!bid.user_id) return;
        allBids.push(bid);
        processBids(); // Only updates biddersMap for rankings, NOT bidderTotals
        // Note: bidderTotals is updated via bidder_total_update event only
        loadStats();
      });

      socket.on('bidder_total_update', (data) => {
        // data: { user_id, user_name, total }
        console.log('Bidder total update:', data);
        
        // When filtering, we need to recalculate the totals properly
        // For now, just refresh the entire dataset when a new bid comes in
        if (currentFilter.type !== 'all') {
          // Trigger a full rebuild for filtered views
          rebuildBidderTotalsFromHistory();
          updateChartAndTable();
        } else {
          // Original behavior for 'all' view
          // Note: Elapsed time for graph x-axis now comes from server via time_sync event
          // No client-side calculations needed
          
          // Get or create bidder entry in bidderTotals
          if (!bidderTotals.has(data.user_id)) {
            bidderTotals.set(data.user_id, {
              user_name: data.user_name,
              points: []
            });
          }
          
          const bidder = bidderTotals.get(data.user_id);
          bidder.points.push({
            x: elapsedMinutes,
            y: data.total
          });
          
          // Update chart
          updateChartAndTable();
        }
      });

      socket.on('bid_updated', async (data) => {
        console.log('Bid updated:', data);
        // Reload all bids and stats to reflect the change
        await loadBids();
        loadStats();
      });

      socket.on('bid_deleted', async (data) => {
        console.log('Bid deleted:', data);
        // Clear selection if the deleted bid was selected
        if (selectedBidId === String(data.bidId)) {
          selectedBidId = null;
          document.getElementById('delete-bid-btn').disabled = true;
        }
        // Reload all bids and stats to reflect the change
        await loadBids();
        loadStats();
      });

      socket.on('bidders_count_update', loadStats);

      // Note: Pause/resume state is now primarily handled by time_sync event
      // These handlers are kept for notifications and backwards compatibility
      socket.on('auction_paused', () => {
        console.log('Auction paused notification received');
        // State is updated via time_sync, just show notification if needed
      });

      socket.on('auction_resumed', () => {
        console.log('Auction resumed notification received');
        // State is updated via time_sync, refresh chart
        updateChartAndTable();
      });

      socket.on('auction_extended', (data) => {
        console.log('Auction extended!', data);
        // Update the auction end time (time_sync will broadcast the new time)
        if (data.newEndTime) {
          auctionEnd = new Date(data.newEndTime);
          extensionCount++;
          document.getElementById('extensions-value').textContent = extensionCount;
          
          // Show a visual notification
          timeSubEl.textContent = `⏱️ Extended by ${data.extensionTime}s`;
          setTimeout(() => {
            timeSubEl.textContent = '';
          }, 3000);
        }
      });

      socket.on('auction_reset', (data) => {
        console.log('Auction reset! Reloading page...');
        window.location.reload();
      });

      socket.on('connect_error', (err) => {
        console.error('Socket connect_error:', err?.message || err);
      });
    }

    // --- Pause/Resume toggle ---
    async function togglePauseResume(){
      if(!auctionLive) return;
      try {
        const isPause = !auctionPaused; // If currently not paused, we're pausing
        const res = await authFetch(`/events/${eventId}/${isPause ? 'pause' : 'resume'}`, { method:'PATCH' });
        if(res.ok){
          // Server handles all timing logic
          // Pause state will be updated via time_sync event
          auctionPaused = isPause;
          setPauseButtonState(isPause);
        }
      } catch(e) {
        console.error(e);
      }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', async () => {
      const params = new URLSearchParams(window.location.search);
      eventId = params.get('event_id');
      if(!eventId){
        alert('Missing event_id');
        window.location.href = 'events.html';
        return;
      }

      // Tab navigation
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.dataset.tab;
          if (tabName === "pricing") {
            // Already on pricing page, do nothing
            return;
          }
          if (tabName === "docs") {
            // Navigate to docs.html
            window.location.href = `docs.html?event_id=${eventId}`;
            return;
          }
          if (tabName === "responses") {
            // Navigate to response.html
            window.location.href = `response.html?eventId=${eventId}`;
            return;
          }
          // Navigate to event.html with the selected tab
          window.location.href = `event.html?id=${eventId}&tab=${tabName}`;
        });
      });

      pauseResumeBtn.addEventListener('click', togglePauseResume);
      
      // DEBUG: Start auction now button
      const debugStartNowBtn = document.getElementById('debug-start-now-btn');
      if (debugStartNowBtn) {
        debugStartNowBtn.addEventListener('click', async () => {
          if (!confirm('DEBUG: Reset auction and start now? This will revert bids to opening.')) return;
          
          try {
            const res = await authFetch(`/events/${eventId}/debug-reset`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            });
            
            if (res.ok) {
              console.log('Auction reset! Starting now. Refreshing...');
              window.location.reload();
            } else {
              const error = await res.json();
              console.error('Failed to reset auction:', error.error || 'Unknown error');
              alert('Failed to reset auction: ' + (error.error || 'Unknown error'));
            }
          } catch (e) {
            console.error('Error resetting auction:', e);
            alert('Error resetting auction: ' + e.message);
          }
        });
      }
      
      // Attach Delete button handler
      const deleteBtn = document.getElementById('delete-bid-btn');
      
      if (deleteBtn) {
        console.log('Delete button found and attaching listener');
        deleteBtn.addEventListener('click', deleteSelectedBid);
      } else {
        console.error('Delete button not found!');
      }

      await loadEvent();
      await loadStats();
      await loadBids();
      
      // Setup bid stream filter after bids are loaded
      setupBidStreamFilter();

      // Display initial countdown before socket connects
      if (auctionEnd) {
        const now = new Date();
        const msRemaining = auctionEnd - now;
        const initialSecondsRemaining = Math.max(0, Math.floor(msRemaining / 1000));
        updateCountdownFromServer(initialSecondsRemaining, auctionPaused);
      }

      // Ensure chart initializes correctly on first page load with proper baseline
      const totalBaseline = Array.from(baselineMap.values()).reduce((acc, li) => acc + (li.ext_baseline || 0), 0);
      lastTotalBaseline = totalBaseline;
      console.log('Initial chart baseline setup:', totalBaseline);
      AuctionGraphs.initChart('bid-chart', totalBaseline, currencySymbol);
      AuctionGraphs.showSavingsByBidder(bidderTotals, currencySymbol, totalBaseline, null, eventId);
      connectSocket();

      // All timing is now controlled by server via time_sync events
      // No client-side countdown intervals needed
    });
  </script>
</body>
</html>